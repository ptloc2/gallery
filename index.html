<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>77Store - Gallery</title>
<link rel="icon" type="image/jpeg" href="./favicon.jpeg">
<style>
:root{
  --accent:#2b82c9;
  --tab-bg:#eaf6ff;
  --tab-border:#d6ecff;
  --tab-text:#1e6fb0;
  --btn-padding:6px 8px;
  --gap:8px;
  --card-radius:8px;
  --progress-max-height:260px;
  --card-min:120px;
  --header-padding:10px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{font-family:system-ui,Arial;margin:0;background:#f0f6fb;color:#072033; -webkit-font-smoothing:antialiased;}
body.dark{ background:#111316; color:#d9dee3 }

#refreshBtn {display: none !important;}
/* header */
header{ padding: 9px; background: var(--tab-bg); position: fixed; top: 0; right:0; left:0; z-index: 60; box-shadow: 0 2px 6px rgba(10,10,10,0.06); overflow: visible; transition: transform 0.22s ease; transform: translateY(0);}
body.dark header{ background:#122028 }

.top-row{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
.top-row > * { min-width:0 }
/*.brand{font-weight:700;color:var(--accent);font-size:15px}*/
.brand{ display:none; }
.search-wrap{ flex:1 1 auto; margin-left:8px; min-width:0; }
.search-input{ width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); font-size:14px; min-width:0; }

header > .controls { display:flex; gap:8px; align-items:center; min-width:0 }

.tabs{ display:flex; gap:8px; overflow-x:auto; padding:8px 12px; margin-top:8px; -webkit-overflow-scrolling: touch; box-sizing:border-box; }
.tab{ padding:8px 10px; border-radius:8px; background:var(--tab-bg); border:1px solid var(--tab-border); cursor:pointer; white-space:nowrap; font-size:13px; color:var(--tab-text); }
.tab.active{ background:var(--accent); color:white; box-shadow:0 2px 8px rgba(0,0,0,0.12) }

main{ padding:10px }
.status{ padding:8px 12px; color:#345; font-size:13px }

/* grid */
.grid{ display: grid; grid-template-columns: repeat(auto-fill, minmax(var(--card-min), 1fr)); gap: var(--gap); }
.card{ background:white; border-radius:var(--card-radius); padding:8px; box-shadow:0 1px 4px rgba(12,15,30,0.06); display:flex; flex-direction:column; gap:6px; font-size:13px; position:relative; align-items:stretch; min-height:170px; overflow:hidden }
body.dark .card{ background:#15181a }
.thumb-wrap{ width:100%; aspect-ratio:1/1; overflow:hidden; border-radius:8px; background:#f6f8fa }
body.dark .thumb-wrap{ background:#222528 }
.card img{ width:100%; height:100%; object-fit:cover; display:block }

/* checkbox */
.checkbox-select{ position:absolute; left:8px; top:8px; z-index:20; width:28px; height:28px; transform:scale(1.2); display:none }
body.body-multiselect .checkbox-select{ display:block }

/* buttons */
.btn{ padding:var(--btn-padding); border-radius:8px; border:1px solid rgba(0,0,0,0.06); cursor:pointer; background:transparent; font-size:13px; color:var(--tab-text) }
.btn.primary{ background:var(--accent); color:#fff; border-color:var(--accent) }
.btn.tab-like{ background:var(--tab-bg); border:1px solid var(--tab-border); color:var(--tab-text) }
body.dark .btn.tab-like{ background:#14232a; border-color:#1b2b32; color:#9fcffb }
.controls-left .btn{ margin-right:12px }

/* share button smaller & icon-only text */
.share-btn{ border:1px solid #cccccc; background:#ffffff; color:#000; white-space:nowrap; display:inline-flex; gap:6px; align-items:center; padding:6px 8px; border-radius:8px; font-size:12px; line-height:1; }
body.dark .share-btn{ background:#222426; color:#e6e9eb; border-color:#444 }

/* actions / sections */
.actions-bar{ display:flex; gap:8px; align-items:center; margin-bottom:8px }
.section-title{ margin:10px 0 6px; font-weight:600; font-size:14px }
.muted{ color:#666; font-size:13px }

/* modal & detail grid */
.modal{ position:fixed; inset:0; background:rgba(0,0,0,0.6); display:none; z-index:120; align-items:center; justify-content:center }
.modal.open{ display:flex }
.modal-content{ background:white; width:92%; height:86%; border-radius:12px; display:flex; flex-direction:column; overflow:auto }
body.dark .modal-content{ background:#0f1315; color:#e6e9eb }
.modal-header{ padding:10px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between }
.modal-body{ padding:10px; overflow:auto }
.detail-grid{ display:grid; grid-template-columns: repeat(4,1fr); gap:8px }
@media(max-width:900px){ .detail-grid{ grid-template-columns: repeat(3,1fr); } }
@media(max-width:480px){ .detail-grid{ grid-template-columns: repeat(2,1fr); } }

/* progress */
.progress-panel { position: fixed; right: 12px; bottom: 12px; padding: 10px; width: 360px; max-width: calc(100% - 24px); background: rgba(255,255,255,0.98); border-radius: 10px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); z-index: 140; display: none; font-size:13px; }
.progress-panel.open { display:block; }
.groups-scroll { max-height: var(--progress-max-height); overflow:auto; padding-right:6px; margin-bottom:8px; }
.progress-row { margin-bottom:8px; border-bottom:1px solid #eee; padding-bottom:6px; }
.progress-bar-bg { width:100%; height:8px; background:#eee; border-radius:6px; overflow:hidden; }
.progress-bar-fill { height:100%; width:0%; background:var(--accent); border-radius:6px; transition: width 0.12s linear; }

/* table add */
.table-wrap{ overflow:auto }
.table-add { width:100%; min-width:900px; border-collapse:collapse; margin:6px 0; }
.table-add th, .table-add td { border:1px solid #e6eef6; padding:6px; text-align:left; vertical-align:middle; font-size:13px; }
.table-add th { background:#f7fbff; font-weight:600; }
.table-add th:nth-child(1), .table-add td:nth-child(1) { width:90px; }
.table-add th:nth-child(2), .table-add td:nth-child(2) { width:160px; }
.table-add th:nth-child(3), .table-add td:nth-child(3) { width:120px; }
.table-add th:nth-child(4), .table-add td:nth-child(4) { width:120px; } /* price col */
.table-add th:nth-child(5), .table-add td:nth-child(5) { width:auto; }
.table-add th:nth-child(6), .table-add td:nth-child(6) { width:120px; }

.small-thumb { width:60px; height:60px; object-fit:cover; border-radius:6px; background:#fafafa; display:block; }
.row-actions { display:flex; gap:6px; align-items:center; }

/* float delete */
.float-delete{ position:fixed; left:12px; bottom:12px; z-index:150; display:none; }
.float-delete button{ background:#ff3b30; color:#fff; border:none; padding:12px 16px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.15); cursor:pointer; font-weight:700; }

/* sort control small */
.sort-inline { display:inline-flex; gap:6px; align-items:center; margin-left:8px; }
.select-small { padding:6px; border-radius:8px; border:1px solid #d6ecff; background:var(--tab-bg); color:var(--tab-text); }

/* responsive */
@media (min-width: 600px) and (max-width: 999px) { .grid{ grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; } }
@media (min-width: 1000px) { .grid{ grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:12px; } }
@media (max-width: 480px){ .progress-panel{ width: 92%; right: 4%; } .grid{ grid-template-columns: repeat(3, 1fr); } }

img{ max-width:100%; display:block }

/* --- new more-panel styles --- */
#more-control { display:inline-block; position:relative; }
#more-btn { padding:6px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:#fff; cursor:pointer; }
#more-panel { position:absolute; right:0; top:42px; width:200px; background:#fff; border:1px solid rgba(0,0,0,0.08); box-shadow:0 6px 18px rgba(0,0,0,0.08); padding:8px; display:none; flex-direction:column; gap:6px; border-radius:8px; z-index:200; }
#more-panel button { width:100%; padding:8px 10px; text-align:left; border-radius:6px; border:none; background:#f6f6f6; cursor:pointer; }
#more-panel button:hover{ background:#eee; }
#more-control.open #more-panel { display:flex; }

</style>
<!-- include SheetJS for Excel export -->
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
<header id="pageHeader">
  <div class="top-row">
    <div class="search-wrap"><input id="searchInput" class="search-input" placeholder="Tìm theo barcode (VD: 146888) — Enter để tìm" /></div>
    <div class="controls" style="flex:0 0 auto">
      <div id="more-control" style="position:relative; display:inline-block;">
        <button id="more-btn" class="btn tab-like" title="More">⋯</button>
        <div id="more-panel" aria-hidden="true">
          <button id="authBtn" class="btn tab-like">Đăng nhập</button>
          <button id="themeToggle" class="btn tab-like">Light/Dark</button>
          <button id="refreshBtn" class="btn tab-like">Refresh</button>
          <button id="btn-export-excel" class="btn tab-like">Xuất Excel</button>
          <button id="import-von-btn" class="btn tab-like">Import giá vốn</button>
	<button id="btn-export-thumbs" class="btn tab-like" style="display:none">Xuất thumbnail</button>
        </div>
      </div>
    </div>
  </div>
  <div id="tabs" class="tabs"></div>
</header>

<main id="mainContent">
  <div id="status" class="status">Đang tải manifest...</div>
  <div id="content"></div>
</main>

<!-- modal -->
<div id="modal" class="modal" role="dialog" aria-hidden="true">
  <div class="modal-content">
    <div class="modal-header">
  <!-- LEFT: title + price + inline edit row (hidden) -->
  <div id="modalHeaderLeft" style="display:flex; flex-direction:column; gap:6px;">
    <div style="font-weight:700"><span id="modalTitle"></span></div>
    <div style="color:#666;font-size:13px">
      Price: <span id="modalPrice">—</span>
    </div>
    <div style="color:#666;font-size:13px">
      Vốn: <span id="modalVon">—</span>
    </div>
    <!-- EDIT ROW: xuất hiện ngay dưới Price khi bấm "Thay giá" -->
    <div id="priceEditRowHeader" style="display:none; margin-top:6px; gap:8px; align-items:center;">
      <input id="modalNewPriceHeader" type="text" placeholder="Nhập giá mới" style="padding:8px;border-radius:8px;border:1px solid #ddd;min-width:160px;">
      <button id="savePriceBtnHeader" class="btn primary">Lưu</button>
      <button id="cancelPriceBtnHeader" class="btn">Hủy</button>
    </div>
  </div>

  <!-- RIGHT: Thay giá button + đóng -->
  <div id="modalHeaderRight" style="display:flex; gap:8px; align-items:center;">
    <button id="changePriceBtn" class="btn">Thay giá</button>
    <button id="modalClose" class="btn">Đóng</button>
  </div>
</div>
    <div class="modal-body" id="modalBody"></div>
  </div>
</div>

<!-- progress panel -->
<div id="progressPanel" class="progress-panel" aria-hidden="true">
  <div class="groups-scroll" id="groupsContainer"></div>
  <div style="margin-top:8px">
    <div style="display:flex;justify-content:space-between;align-items:center"><div>Overall</div><div id="overallPercent">0%</div></div>
    <div class="progress-bar-bg" style="margin-top:6px"><div id="overallBar" class="progress-bar-fill" style="width:0%"></div></div>
    <div style="display:flex;justify-content:flex-end;margin-top:8px"><button id="closeProgressBtn" class="btn">Ẩn</button></div>
  </div>
</div>

<!-- floating delete -->
<div id="floatDelete" class="float-delete" aria-hidden="true"><button id="floatDeleteBtn">Xóa</button></div>
<input id="import-von-input" type="file" accept=".xlsx,.xls" style="display:none" />

<script>
/* CONFIG */
const R2_PUBLIC_BASE = "https://pub-9a763a2453ba41939860c4caded896a0.r2.dev";
const WORKER_BASE = "https://test.lapproak0.workers.dev";
const WORKER_BASE1= "https://shoes-worker.lapproak0.workers.dev";
const PREFIX = "Shoes";

/* DOM */
const statusEl = document.getElementById('status');
const tabsEl = document.getElementById('tabs');
const contentEl = document.getElementById('content');
const searchInput = document.getElementById('searchInput');
const refreshBtn = document.getElementById('refreshBtn');
const themeToggle = document.getElementById('themeToggle');

const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalBody = document.getElementById('modalBody');

const progressPanel = document.getElementById('progressPanel');
const groupsContainer = document.getElementById('groupsContainer');
const overallBar = document.getElementById('overallBar');
const overallPercent = document.getElementById('overallPercent');
const closeProgressBtn = document.getElementById('closeProgressBtn');

const floatDelete = document.getElementById('floatDelete');
const floatDeleteBtn = document.getElementById('floatDeleteBtn');

// global von map cache
let GLOBAL_VON_MAP = null;
let GLOBAL_VON_LOADING = null;

let __currentVonAbortController = null;
let manifestRaw = null;
let manifest = null;
let manifestMap = {};
let activeTab = 'all';
let selectedItems = new Set();
let multiSelectMode = false;
let priceSortMode = 'asc'; // 'asc' | 'desc' | null

async function loadGlobalVonMap(force = false) {
  if (!force && GLOBAL_VON_MAP) return GLOBAL_VON_MAP;
  if (GLOBAL_VON_LOADING) return GLOBAL_VON_LOADING;
  GLOBAL_VON_LOADING = fetch(`${WORKER_BASE}/von`, { cache: 'no-store' })
    .then(r => {
      if (!r.ok) throw new Error('von fetch status ' + r.status);
      return r.json();
    })
    .then(j => {
      // if endpoint returns {code:..., von:...} (single) treat accordingly
      if (j && typeof j === 'object' && !Array.isArray(j) && Object.keys(j).length && !('code' in j && 'von' in j)) {
        GLOBAL_VON_MAP = j;
      } else {
        // fallback: maybe worker returned {code, von} for a single code -> build map with that
        if (j && j.code) { GLOBAL_VON_MAP = GLOBAL_VON_MAP || {}; GLOBAL_VON_MAP[j.code] = j.von; }
        GLOBAL_VON_MAP = GLOBAL_VON_MAP || {};
      }
      GLOBAL_VON_LOADING = null;
      return GLOBAL_VON_MAP;
    })
    .catch(err => {
      console.warn('loadGlobalVonMap failed', err);
      GLOBAL_VON_LOADING = null;
      return GLOBAL_VON_MAP || {};
    });
  return GLOBAL_VON_LOADING;
}

/* session admin key */
function getAdminKeySession() {return sessionStorage.getItem('admin_key_v1') || null;}
function setAdminKeySession(key) {if (!key) sessionStorage.removeItem('admin_key_v1');else sessionStorage.setItem('admin_key_v1', key);} 
// Thay thế promptAndValidateAdminKey() bằng hàm này
async function promptAndValidateAdminKey(){
  const existing = getAdminKeySession(); if (existing) return existing;
  while (true) {
    const input = prompt('Nhập mật khẩu:');
    if (!input) return null;
    const trimmed = input.trim();
    if (!trimmed) { alert('Mật khẩu rỗng. Nhập lại?'); continue; }
    try {
      const res = await fetch(WORKER_BASE + '/validate-key', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-api-key': trimmed },
        cache: 'no-store',
        body: JSON.stringify({ now: Date.now() })
      });
      if (res.status === 200) {
        setAdminKeySession(trimmed);
        // optional: refresh manifest in background without blocking UI
        fetchManifest().catch(()=>{});
        return trimmed;
      } else if (res.status === 401) {
        alert('Admin key không hợp lệ (401). Vui lòng thử lại.');
        continue;
      } else {
        const txt = await res.text().catch(()=> '');
        alert('Lỗi khi kiểm tra key. Status: ' + res.status + (txt ? (' — ' + txt) : ''));
        continue;
      }
    } catch (err) {
      console.warn('Error validating admin key:', err);
      if (!confirm('Lỗi mạng khi kiểm tra admin key. Thử lại?')) return null;
      continue;
    }
  }
}

/* role helpers stored in session */
function getRole(){ return sessionStorage.getItem('user_role_v1') || 'anon'; } // 'anon'|'limited'|'admin'
function setRole(r){ if(!r || r==='anon') sessionStorage.removeItem('user_role_v1'); else sessionStorage.setItem('user_role_v1', r); }

/* update UI visibility based on role */
function updateRoleVisibility(){
  const role = getRole();
  const authBtn = document.getElementById('authBtn');
  if(authBtn) authBtn.textContent = (role === 'anon') ? 'Đăng nhập' : 'Đăng xuất';
  // show/hide Refresh: only show after any login
  const refreshBtn = document.getElementById('refreshBtn');
  if(refreshBtn) refreshBtn.style.display = (role === 'anon') ? 'none' : 'inline-block';
  // Export visible only for admin
  const exportBtn = document.getElementById('btn-export-excel');
  if(exportBtn) exportBtn.style.display = (role === 'admin') ? 'inline-block' : 'none';
  // Import (if exists) visible only for admin
  const importBtn = document.getElementById('import-von-btn');
  if(importBtn) importBtn.style.display = (role === 'admin') ? 'inline-block' : 'none';
 // Thumbnail export: visible for any logged-in role (limited OR admin)
  const thumbBtn = document.getElementById('btn-export-thumbs');
  if(thumbBtn) {
    thumbBtn.style.display = (role === 'anon') ? 'none' : 'inline-block';
  }
}


/* handle login/logout flow:*/
async function handleLoginClick(){
  const current = getRole();
  if(current !== 'anon'){
    if(!confirm('Đăng xuất?')) return;
    // sign out
    setRole('anon');
    setAdminKeySession(null);
    updateRoleVisibility();
    return;
  }
 
  while(true){
    const raw = prompt('Nhập mật khẩu:');
    if(raw === null) return;
    const input = String(raw || '').trim();
    if(!input){ alert('Mật khẩu rỗng. Nhập lại?'); continue; }

    if(input.toLowerCase() === 'yes'){
      // admin path: prompt admin key using existing validator
      const key = await promptAndValidateAdminKey();
      if(!key){ alert('Mật khẩu không hợp lệ hoặc huỷ.'); continue; }
      setRole('admin');
      updateRoleVisibility();
      return;
    }
    // treat input as admin-key candidate: validate by calling validate-key (lightweight)
try{
  const res = await fetch(WORKER_BASE + '/validate-key', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'x-api-key': input },
    body: JSON.stringify({ now: Date.now() }),
    cache: 'no-store'
  });
  if (res.status === 200) {
    // key hợp lệ (lightweight check) -> limited
    setAdminKeySession(input);
    setRole('limited');
    updateRoleVisibility();
    return;
  } else if (res.status === 401) {
    alert('Mật khẩu không hợp lệ.');
    continue;
  } else {
    const txt = await res.text().catch(()=> '');
    alert('Lỗi khi kiểm tra key. Status: ' + res.status + (txt ? (' — ' + txt) : ''));
    continue;
  }
} catch (e) {
  console.warn('validate key error', e);
  alert('Lỗi mạng khi kiểm tra key. Thử lại.');
  continue;
}
  }
}
/* ensureAuthForAction:
 - if anon => call handleLoginClick() (so UI updates via login button flow)
 - returns { ok:true/false, key: string|null }
*/
async function ensureAuthForAction(){
  const role = getRole();
  if(role === 'anon'){
    await handleLoginClick();
  }
  const newRole = getRole();
  if(newRole === 'anon') return { ok:false, key:null };
  return { ok:true, key: getAdminKeySession() || null };
}

/* theme */
function applyTheme(isDark){ document.body.classList.toggle('dark', !!isDark); sessionStorage.setItem('dark_mode_v1', !!isDark); }
themeToggle.onclick = ()=>{ const isDark = !document.body.classList.contains('dark'); applyTheme(isDark); };
(function(){ const ds = sessionStorage.getItem('dark_mode_v1'); if(ds==='true') applyTheme(true); })();

/* helpers */
function logStatus(msg){ statusEl.textContent = msg; console.log(msg); }
function showModal(title, htmlOrNode){ modalTitle.textContent = title; if(typeof htmlOrNode === 'string') modalBody.innerHTML = htmlOrNode; else { modalBody.innerHTML=''; modalBody.appendChild(htmlOrNode);} modal.classList.add('open'); modal.setAttribute('aria-hidden','false'); }

document.getElementById('modalClose').onclick = ()=>{
  // abort von fetch if any
  try { if (__currentVonAbortController) __currentVonAbortController.abort(); } catch(e){/*ignore*/}
  __currentVonAbortController = null;
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden','true');
};
modal.onclick = (e)=>{ if(e.target === modal) document.getElementById('modalClose').click(); };

/* manifest normalization: IGNORE keys that are not sizes */
function normalizeManifest(raw){
  if(!raw) return { sizes: [] };
  if(Array.isArray(raw)) return { sizes: raw };
  if(raw.sizes && Array.isArray(raw.sizes)) {
    return { sizes: raw.sizes.map(s=>({ size: String(s.size||s.name||'').trim(), barcodes: Array.isArray(s.barcodes) ? s.barcodes.map(b=>({ code: String(b.code||'').trim(), images: Array.isArray(b.images)?b.images.slice():[], price: b.price })) : [] })) };
  }
  const sizes=[];
  const IGNORE_KEYS = new Set(['meta','version','manifest','trash']);
  for(const [k,v] of Object.entries(raw)){
    if(IGNORE_KEYS.has(String(k).toLowerCase())) continue;
    if(v && typeof v === 'object' && !Array.isArray(v)){
      const barcodes=[];
      for(const [code, imgs] of Object.entries(v)){
        if(Array.isArray(imgs)) barcodes.push({ code: String(code).trim(), images: imgs.slice() });
        else if(imgs && typeof imgs === 'object' && Array.isArray(imgs.images)) barcodes.push({ code: String(code).trim(), images: imgs.images.slice(), price: imgs.price });
      }
      if(barcodes.length) sizes.push({ size: String(k).trim(), barcodes });
    }
  }
  sizes.sort((a,b)=> { const ai=parseInt(a.size), bi=parseInt(b.size); if(!isNaN(ai)&&!isNaN(bi)) return ai-bi; return a.size.localeCompare(b.size); });
  return { sizes };
}

/* manifest map */
function buildManifestMap(){
  manifestMap = {};
  if(!manifest || !Array.isArray(manifest.sizes)) return;
  for(const s of manifest.sizes){
    const sizeKey = String(s.size).trim();
    manifestMap[sizeKey] = manifestMap[sizeKey] || {};
    for(const b of s.barcodes){ manifestMap[sizeKey][String(b.code).trim()] = true; }
  }
}
function manifestHas(size, barcode){ return !!(manifestMap[String(size).trim()] && manifestMap[String(size).trim()][String(barcode).trim()]); }

/* fetch manifest */
async function fetchManifest({ forceRefresh=false }={}) {
  try {
    logStatus('Loading manifest...');
    if(forceRefresh){
      const key = await promptAndValidateAdminKey(); if(!key) return; 
      const r = await fetch(WORKER_BASE + '/refresh-manifest', { method:'POST', headers:{ 'x-api-key': key }});
      if(!r.ok){ const t=await r.text().catch(()=>r.statusText); throw new Error('Refresh failed: ' + t); }
      manifestRaw = await r.json();
    } else {
      const r = await fetch(WORKER_BASE + '/manifest.json', { cache:'no-store' });
      if(!r.ok){ const t=await r.text().catch(()=>r.statusText); throw new Error('manifest fetch ' + r.status); }
      manifestRaw = await r.json();
    }
    manifest = normalizeManifest(manifestRaw || {});
    buildManifestMap();
    logStatus('');
    buildTabs();
  } catch(err){
    console.error(err); logStatus('Không load được manifest: ' + err.message); contentEl.innerHTML='';
  }
}

/* ----------------- new UI & export Excel logic ----------------- */
// toggle more panel
(function(){
  const moreControl = document.getElementById('more-control');
  const moreBtn = document.getElementById('more-btn');
  if(!moreControl || !moreBtn) return;
  moreBtn.addEventListener('click', (e)=>{ e.stopPropagation(); moreControl.classList.toggle('open'); });
  document.addEventListener('click', (e)=>{ if(!moreControl.contains(e.target)) moreControl.classList.remove('open'); });
  document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') moreControl.classList.remove('open'); });
})();

function flattenManifestToRows(man) {
  const rows = [];
  if (!man) return rows;
  if (Array.isArray(man.sizes)) {
    for (const s of man.sizes) {
      for (const b of (s.barcodes || [])) {
        const code = String(b.code || '').trim();
        const price = b.price != null ? b.price : null;
        if (code) rows.push([code, price]);
      }
    }
    return rows;
  }
  for (const sizeKey of Object.keys(man)) {
    const block = man[sizeKey];
    if (!block || typeof block !== 'object') continue;
    for (const code of Object.keys(block)) {
      const entry = block[code];
      let price = null;
      if (Array.isArray(entry)) price = null;
      else if (entry && typeof entry === 'object') price = entry.price != null ? entry.price : null;
      rows.push([String(code).trim(), price != null ? String(price) : null]);
    }
  }
  return rows;
}

async function exportExcelFromModel() {
  try {
    // ensure manifest up-to-date (non-force)
    await fetchManifest();

    // build rows with size + thumb URL
    const rows = [];
    for (const s of (manifest.sizes || [])) {
      const size = String(s.size || '').trim();
      for (const b of (s.barcodes || [])) {
        const code = String(b.code || '').trim();
        const price = b.price != null ? String(b.price) : '';
        // chọn thumb filename: ưu tiên file có 'thumb' trong tên, fallback file đầu hoặc 'thumb.jpeg'
        const thumbName = (Array.isArray(b.images) && b.images.find(n => /thumb/i.test(n)))
                        || (Array.isArray(b.images) && b.images[0])
                        || 'thumb.jpeg';
        const thumbUrl = `${R2_PUBLIC_BASE}/${PREFIX}/${encodeURIComponent(size)}/${encodeURIComponent(code)}/${encodeURIComponent(thumbName)}`;
        rows.push({ code, price, size, thumbName, thumbUrl });
      }
    }
    if (!rows.length) { alert('Không có dữ liệu trong manifest để xuất.'); return; }

    // fetch model.xlsx at same folder level
    const modelUrl = './model.xlsx';
    const ab = await fetch(modelUrl).then(r=>{ if(!r.ok) throw new Error('model.xlsx fetch ' + r.status); return r.arrayBuffer(); });

    const wb = XLSX.read(ab, { type: 'array' });
    const firstSheetName = wb.SheetNames[0];
    const ws = wb.Sheets[firstSheetName];

    // compute start row (zero-based)
    const range = ws['!ref'] ? XLSX.utils.decode_range(ws['!ref']) : { s:{r:0,c:0}, e:{r:0,c:0} };
    const startRowZero = range.e.r + 1;

    // --- load whole von map once (preferred) ---
    let vonMap = {};
    try {
      const vres = await fetch(`${WORKER_BASE}/von`, { cache: 'no-store' });
      if (vres.ok) {
        const j = await vres.json().catch(()=>null);
        if (j && typeof j === 'object') vonMap = j;
      } else {
        console.warn('von fetch returned', vres.status);
      }
    } catch (e) {
      console.warn('fetch von.json failed', e);
    }

    // write each row: many columns as your mapping; column C(index2)=code, G(index6)=price*1000, H(index7)=von (number)
    for (let i = 0; i < rows.length; i++) {
      const r = startRowZero + i;
      const code = rows[i].code || '';
      const priceRaw = rows[i].price || '';
      const priceNum = parseInt(String(priceRaw).replace(/[^\d]/g,'')) || 0;
      const priceToWrite = priceNum * 1000;

      // von: get from vonMap by exact code key; sanitize to integer (no dots)
      let vonVal = '';
      try {
        const maybe = vonMap && (vonMap.hasOwnProperty(code) ? vonMap[code] : (vonMap[code] === 0 ? 0 : undefined));
        if (maybe !== undefined && maybe !== null && String(maybe).trim() !== '') {
          const iv = parseInt(String(maybe).replace(/[^\d]/g,''), 10);
          if (!Number.isNaN(iv)) vonVal = iv;
        }
      } catch (e) {
        vonVal = '';
      }

      // fill cells (A,B,C,D,E,G,H,...) per your template
      ws[XLSX.utils.encode_cell({ c: 0, r })] = { t: 's', v: 'Hàng hoá' }; //col A
      ws[XLSX.utils.encode_cell({ c: 1, r })] = { t: 's', v: 'Giày Bóng Rổ' }; //col B
      ws[XLSX.utils.encode_cell({ c: 2, r })] = { t: 's', v: code }; //col C
      ws[XLSX.utils.encode_cell({ c: 3, r })] = { t: 's', v: code }; //col C
      ws[XLSX.utils.encode_cell({ c: 4, r })] = { t: 's', v: 'Giày Bóng Rổ - ' + code }; //col E
      // column G = index 6 : price (as number)
      ws[XLSX.utils.encode_cell({ c: 6, r })] = { t: 'n', v: priceToWrite };
      // col H index 7 = Vốn (vonVal numeric) or empty
      if (vonVal !== '') {
        ws[XLSX.utils.encode_cell({ c: 7, r })] = { t: 'n', v: Number(vonVal) };
      } else {
        ws[XLSX.utils.encode_cell({ c: 7, r })] = { t: 's', v: '0' };
      }
      // other fixed columns as in your original
      ws[XLSX.utils.encode_cell({ c: 8, r })] = { t: 's', v: 1 }; //ton kho
      ws[XLSX.utils.encode_cell({ c: 9, r })] = { t: 's', v: 1 };
      ws[XLSX.utils.encode_cell({ c: 10, r })] = { t: 's', v: 1 };
      ws[XLSX.utils.encode_cell({ c: 11, r })] = { t: 's', v: 1 };
      // thumb url into column Q (index 16) as you used before
      ws[XLSX.utils.encode_cell({ c: 16, r })] = { t: 's', v: rows[i].thumbUrl || '' };
    }

    // update sheet range (ensure it covers at least column Q / index 16)
    const newER = startRowZero + rows.length - 1;
    const newEC = Math.max(range.e.c || 16, 16);
    const newRange = { s: { r: Math.min(range.s.r, 0), c: 0 }, e: { r: Math.max(range.e.r, newER), c: newEC } };
    ws['!ref'] = XLSX.utils.encode_range(newRange);

    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([wbout], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url;
    a.download = `export_${PREFIX}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.xlsx`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);

    document.getElementById('more-control').classList.remove('open');
  } catch (err) {
    console.error('exportExcel error', err);
    alert('Xuất Excel lỗi: ' + (err && err.message ? err.message : String(err)));
  }
}

document.getElementById('authBtn').addEventListener('click', ()=>{ handleLoginClick(); });
document.getElementById('btn-export-excel').addEventListener('click', exportExcelFromModel);

/* ---------------------------------------------------------------- */

/* tabs */
function createTabButton(text, key){
  const btn = document.createElement('button');
  btn.className = 'tab' + (activeTab===key ? ' active' : '');
  btn.textContent = text; btn.dataset.key = key;
  btn.onclick = ()=>{
    activeTab = key;
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    setActiveButton();
    renderAccording();
  };
  return btn;
}
function setActiveButton(){ document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active')); const btn = document.querySelector(`.tab[data-key="${activeTab}"]`); if(btn) btn.classList.add('active'); }
function buildTabs(){
  tabsEl.innerHTML = '';
  tabsEl.appendChild(createTabButton('Tất cả','all'));
  for (const s of manifest.sizes) {
  const cleanLabel = String(s.size).replace(/^Size\s*/i, '').trim(); // bỏ tiền tố "Size "
  tabsEl.appendChild(createTabButton(cleanLabel, 'size:' + s.size));
	}
  const spacer = document.createElement('div'); spacer.style.flex='1'; tabsEl.appendChild(spacer);
  tabsEl.appendChild(createTabButton('Thêm','add'));
  setActiveButton();
  renderAccording();
}

/* card */
function makeCard(size, bc, withCheckbox=false){
  const card = document.createElement('div'); card.className='card';
  if(withCheckbox || multiSelectMode){
    const cb = document.createElement('input'); cb.type='checkbox'; cb.className='checkbox-select';
    const key = `${String(size).trim()}|${String(bc.code).trim()}`;
    cb.checked = selectedItems.has(key);
    cb.onchange = (e)=> { if(e.target.checked) selectedItems.add(key); else selectedItems.delete(key); };
    card.appendChild(cb);
  }

  const thumbName = (Array.isArray(bc.images) && bc.images.find(x=>/thumb/i.test(x))) || (Array.isArray(bc.images)? bc.images[0] : null) || 'thumb.jpeg';
  const encSize = encodeURIComponent(String(size).trim());
  const encCode = encodeURIComponent(String(bc.code).trim());
  const src = `${WORKER_BASE1}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(thumbName)}`;

  const wrap = document.createElement('div'); wrap.className='thumb-wrap';
  const img = document.createElement('img'); img.src = src; img.alt = bc.code;
  img.onerror = ()=>{ img.style.opacity=0.6; img.style.objectFit='contain' };
  img.onclick = ()=> openDetails(size, bc);
  wrap.appendChild(img);
  card.appendChild(wrap);

  const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='center'; row.style.gap='8px';
  const shareBtn = document.createElement('button'); shareBtn.className='btn share-btn';
  // icon + bold barcode only
  shareBtn.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" style="vertical-align:middle;">
  <path fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" d="M16 4h2a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h2"/>
  <rect x="8" y="2" width="8" height="4" rx="1" fill="none" stroke="currentColor" stroke-width="1.4"/>
</svg>
    <span style="font-weight:700">Lưu / Share</span>
  `;
  shareBtn.onclick = ()=> shareMultipleImages(size, bc);
  row.appendChild(shareBtn);

  card.appendChild(row);
  return card;
}

/* open details */
// helper format/unformat nếu chưa có (giữ lại nếu đã tồn tại)
function formatMoney(val){
  if(val === null || val === undefined || val === '') return '—';
  const s = String(val).replace(/[^\d]/g,'');
  if(!s) return '—';
  return s.replace(/\B(?=(\d{3})+(?!\d))/g, ".") + 'k';
}
function unformatMoney(s){
  return String(s||'').replace(/[^\d]/g,'').trim();
}

// mở modal chi tiết, với editPrice nằm ngay dưới Price:...
async function openDetails(size, bc){
  // header elements
  const titleEl = document.getElementById('modalTitle');
  const priceEl = document.getElementById('modalPrice');
  const changeBtn = document.getElementById('changePriceBtn');
  const priceEditRow = document.getElementById('priceEditRowHeader');
  const newPriceInput = document.getElementById('modalNewPriceHeader');
  const saveBtn = document.getElementById('savePriceBtnHeader');
  const cancelBtn = document.getElementById('cancelPriceBtnHeader');

  // set title + price
  titleEl.textContent = `${size} — ${bc.code}`;
  priceEl.textContent = formatMoney(bc.price);
  
   // show von immediately if cached; otherwise show loading and fetch full map in background
  // at top of openDetails after setting title/price:
// at top of openDetails after setting title/price:
const vonSpan = document.getElementById('modalVon');
if(vonSpan){
  if(getRole() === 'admin'){
    vonSpan.textContent = 'Đang tải...';
    // fetch von (you already had fetch logic — keep it, or reuse loadGlobalVonMap)
    fetch(WORKER_BASE + '/von?code=' + encodeURIComponent(String(bc.code).trim()), { cache: 'no-store' })
      .then(r => r.ok ? r.json() : null)
      .then(j => { vonSpan.textContent = (j && j.von) ? formatMoney(j.von) : '—'; })
      .catch(e => { console.warn(e); vonSpan.textContent = '—'; });
    // ensure visible
    vonSpan.parentElement.style.display = 'block';
  } else {
    // hide the whole row when not admin
    if(vonSpan.parentElement) vonSpan.parentElement.style.display = 'none';
  }
}
  
  // ensure edit area hidden & prefilled
  priceEditRow.style.display = 'none';
  newPriceInput.value = bc.price ? unformatMoney(bc.price) : '';

  // wire: show edit row under Price
  changeBtn.onclick = () => {
    priceEditRow.style.display = 'flex';
    // small visual: focus and select
    newPriceInput.focus();
    newPriceInput.select();
  };

  // cancel
  cancelBtn.onclick = () => {
    priceEditRow.style.display = 'none';
    newPriceInput.value = bc.price ? unformatMoney(bc.price) : '';
  };

  // save: send to worker (complete-upload) and update UI
 saveBtn.onclick = async () => {
  const raw = unformatMoney(newPriceInput.value || ''); // hoặc modalNewPriceHeader
  if (!raw) { alert('Vui lòng nhập giá hợp lệ (chỉ chữ số).'); newPriceInput.focus(); return; }

  // đảm bảo có admin key
  let adminKey = getAdminKeySession();
  if (!adminKey) {
    adminKey = await promptAndValidateAdminKey();
    if (!adminKey) { alert('Cần admin key để lưu giá.'); return; }
  }

  saveBtn.disabled = true;
  saveBtn.textContent = 'Đang lưu...';

  try {
    // 1) Ghi price.txt & update entry cho barcode
    const resp = await fetch(WORKER_BASE + '/complete-upload', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': adminKey },
      body: JSON.stringify({ size: String(size).trim(), barcode: String(bc.code).trim(), price: raw })
    });
    if (!resp.ok) {
      const txt = await resp.text().catch(()=>resp.statusText);
      throw new Error(txt || ('Status ' + resp.status));
    }

    // 2) Sau khi cập nhật entry đơn, gọi refresh-manifest để rebuild toàn bộ manifest (nên làm)
    /*try {
      const r2 = await fetch(WORKER_BASE + '/refresh-manifest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-api-key': adminKey },
        body: JSON.stringify({ now: Date.now() })
      });
      if (!r2.ok) {
        // không fatal: vẫn cố fetch manifest client-side (partial)
        console.warn('refresh-manifest failed', r2.status);
      } else {
        // optional: consume response if needed
        await r2.json().catch(()=>null);
      }
    } catch (e) {
      console.warn('refresh-manifest error', e);
    }*/

    // 3) reload client manifest để UI cập nhật
    try { await fetchManifest(); } catch(e){ console.warn('fetchManifest failed after save', e); }

    // cập nhật UI local
    bc.price = raw; // cập nhật object hiện tại
    const priceSpan = document.getElementById('modalPrice') || document.querySelector('#modalPrice');
    if (priceSpan) priceSpan.textContent = formatMoney(raw);

    priceEditRow.style.display = 'none';
    alert('Đã cập nhật giá và làm mới manifest.');
  } catch (err) {
    console.error('Save price error', err);
    alert('Lỗi khi lưu giá: ' + (err.message || err));
  } finally {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Lưu';
  }
};
  // render images in modal body
  modalBody.innerHTML = '';
  const imgs = bc.images || [];
  const div = document.createElement('div'); div.className='detail-grid';
  for(const fn of imgs){
    const imWrap = document.createElement('div');
    const im = document.createElement('img');
    im.src = `${WORKER_BASE1}/${PREFIX}/${encodeURIComponent(String(size).trim())}/${encodeURIComponent(String(bc.code).trim())}/${encodeURIComponent(fn)}`;
    im.style.width='100%'; im.style.height='100%'; im.style.objectFit='cover';
    imWrap.appendChild(im);
    div.appendChild(imWrap);
  }
  modalBody.appendChild(div);

  // show modal
  modal.classList.add('open'); modal.setAttribute('aria-hidden','false');

  // ensure close works (existing button has id modalClose)
  document.getElementById('modalClose').onclick = ()=>{ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); };
}

/* actions bar */
function renderActionsBar(){
  const bar = document.createElement('div'); bar.className='actions-bar'; bar.style.justifyContent='space-between'; bar.style.marginBottom='10px';
  const left = document.createElement('div');

  if(activeTab !== 'add'){
    // toggle + "Chọn theo excel" + sort control (REPLACE phần cũ)
const toggleBtn = document.createElement('button');
toggleBtn.className = 'btn tab-like';
toggleBtn.textContent = multiSelectMode ? 'Hủy' : 'Chọn xóa';

// helper đảm bảo class body cho multiselect
function updateBodyMultiselectClass(){
  document.body.classList.toggle('body-multiselect', !!multiSelectMode);
}

// tạo nút "Chọn theo excel"
const chooseExcelBtn = document.createElement('button');
chooseExcelBtn.className = 'btn tab-like';
chooseExcelBtn.textContent = 'Chọn theo excel';
chooseExcelBtn.style.display = multiSelectMode ? 'inline-block' : 'none';
chooseExcelBtn.style.marginLeft = '10px'; // khoảng cách giữa nút excel và nút Hủy
// không kiểm tra login ở đây (theo yêu cầu) — nếu bạn muốn giới hạn lại, thêm kiểm tra getRole() tại đây
chooseExcelBtn.onclick = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.xlsx,.xls';
  input.onchange = async (e) => {
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try {
      const ab = await f.arrayBuffer();
      const wb = XLSX.read(ab, { type: 'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1 }); // array of arrays, first row = header
      if(!rows || rows.length === 0) return alert('File Excel rỗng.');

      // try find header indices by fuzzy match; fall back to B=1, C=2, I=8 (zero-based indexes)
      const header = (rows[0] || []).map(h => (h || '').toString().trim().toLowerCase());
      function findIndex(candidates){
        for(const cand of candidates){
          const lc = cand.toLowerCase();
          const idx = header.findIndex(h => h === lc || (h && h.indexOf(lc) !== -1));
          if(idx >= 0) return idx;
        }
        return -1;
      }
      const idxGroup = findIndex(['nhóm hàng(3 cấp)','nhóm hàng','nhóm','nhóm hàng 3 cấp']); // col B prefer
      const idxCode  = findIndex(['mã hàng','mã','mã sản phẩm','code']) ;
      const idxStock = findIndex(['tồn kho','tồn','quantity','on hand','stock']); // col I prefer
      const colGroup = idxGroup >= 0 ? idxGroup : 1;
      const colCode  = idxCode  >= 0 ? idxCode  : 2;
      const colStock = idxStock >= 0 ? idxStock : 8;

      const codesSet = new Set();
      for(let i = 1; i < rows.length; i++){
        const row = rows[i] || [];
        const rawGroup = (row[colGroup] === undefined || row[colGroup] === null) ? '' : String(row[colGroup]).trim();
        const rawStock = row[colStock];
        const rawCode = (row[colCode] === undefined || row[colCode] === null) ? '' : String(row[colCode]).trim();

        // normalize group: match words 'giày' and 'bóng rổ' (case-insensitive, ignore accents)
        const groupNorm = rawGroup.toLowerCase();
        const isBasket = groupNorm.includes('giày') && groupNorm.includes('bóng') && groupNorm.includes('rổ') || groupNorm === 'giày bóng rổ' || groupNorm.includes('giày bóng rổ');

        // check stock == 0 (handle number or string)
        let isZero = false;
        if (rawStock === 0 || rawStock === '0' || rawStock === '0.0' || rawStock === 0.0) isZero = true;
        else {
          const num = Number(String(rawStock || '').replace(/,/g,'.').trim());
          if (!isNaN(num) && num === 0) isZero = true;
        }

        if (isBasket && isZero && rawCode) codesSet.add(String(rawCode));
      }

      if (codesSet.size === 0){
        alert('Không tìm thấy mã nào thỏa điều kiện (Nhóm="Giày Bóng Rổ" và Tồn kho=0). Hãy kiểm tra file hoặc header.');
        return;
      }

      const codes = Array.from(codesSet);
      const preview = codes.slice(0, 200).join(', '); // limit length
      //if(!confirm(`Tìm được ${codes.length} mã:\n${preview}${codes.length>200?'\n... (bỏ qua phần còn lại)': ''}\n\nOK để tích những mã này trên web?`)) return;

      // bật multiSelectMode và chọn các mã tìm thấy (nếu có trong manifest)
      // ensure multiSelectMode on and add to selectedItems for matching sizes
multiSelectMode = true;

const matched = [];   // unique codes that exist in manifest
const notFound = [];  // codes not found at all

for (const rawCode of codes) {
  const code = String(rawCode || '').trim();
  if (!code) continue;
  let foundAny = false;

  for (const s of (manifest && manifest.sizes || [])) {
    const sizeKey = String(s.size || '').trim();
    if (manifestMap[sizeKey] && manifestMap[sizeKey][code]) {
      // add every matching size|code pair (so user can delete exact items)
      selectedItems.add(`${sizeKey}|${code}`);
      foundAny = true;
    }
  }

  if (foundAny) {
    if (!matched.includes(code)) matched.push(code);
  } else {
    notFound.push(code);
  }
}

// show summary to user
const previewMatched = matched.slice(0, 200).join(', ');
let summary = `Tổng mã trong file: ${codes.length}\nMã khớp trên manifest: ${matched.length}\nMã không tìm thấy: ${notFound.length}\n\nMã khớp : ${previewMatched}`;
if (matched.length > 200) summary += '\n... (bỏ qua phần còn lại)';
if (notFound.length > 0) summary += `\n\nMột số mã NOT FOUND: ${notFound.slice(0,20).join(', ')}${notFound.length>20?'\n...':''}`;

alert(summary);

// reflect UI
try { updateBodyMultiselectClass(); } catch(e){/* optional */ }
floatDelete.style.display = 'block';
if (typeof chooseExcelBtn !== 'undefined' && chooseExcelBtn) chooseExcelBtn.style.display = 'inline-block';
renderAccording();

      updateBodyMultiselectClass();
      floatDelete.style.display = 'block';
      // ensure chooseExcelBtn visible now
      chooseExcelBtn.style.display = 'inline-block';
      renderAccording();
    } catch(err){
      console.error('Import excel error', err);
      alert('Lỗi khi đọc file Excel: ' + (err && err.message ? err.message : err));
    }
  };
  input.click();
};

// append toggle + chooseExcel + sort
left.appendChild(toggleBtn);
left.appendChild(chooseExcelBtn);

// sort by price inline control (unchanged)
const sortWrap = document.createElement('div');
sortWrap.className = 'sort-inline';
const sortSel = document.createElement('select');
sortSel.className = 'select-small';
const optAsc = document.createElement('option'); optAsc.value = 'asc'; optAsc.textContent = 'Giá tăng dần';
const optDesc = document.createElement('option'); optDesc.value = 'desc'; optDesc.textContent = 'Giá giảm dần';
sortSel.appendChild(optAsc); sortSel.appendChild(optDesc);
sortSel.value = priceSortMode || 'asc';
sortSel.onchange = ()=>{ priceSortMode = sortSel.value; if(activeTab === 'all') applyPriceSortAndRender(priceSortMode); else renderAccording(); };
sortWrap.appendChild(sortSel);
left.appendChild(sortWrap);

// override toggle behavior (uses closure so chooseExcelBtn can be updated)
toggleBtn.onclick = ()=> {
  multiSelectMode = !multiSelectMode;
  if(!multiSelectMode) selectedItems.clear();
  updateBodyMultiselectClass();
  floatDelete.style.display = multiSelectMode ? 'block' : 'none';
  // show chooseExcelBtn only when multiSelectMode ON
  chooseExcelBtn.style.display = multiSelectMode ? 'inline-block' : 'none';
  // update label text
  toggleBtn.textContent = multiSelectMode ? 'Hủy' : 'Chọn xóa';
  renderAccording();
};


  } else {
    const spacer = document.createElement('div'); spacer.style.height='1px'; spacer.style.display='inline-block'; left.appendChild(spacer);
  }

  bar.appendChild(left);
  const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
  bar.appendChild(right);
  return bar;
}

/* progress helpers */
function showProgressPanel(){ progressPanel.classList.add('open'); progressPanel.setAttribute('aria-hidden','false'); }
function hideProgressPanel(){ progressPanel.classList.remove('open'); progressPanel.setAttribute('aria-hidden','true'); }
closeProgressBtn.onclick = ()=> hideProgressPanel();
function scrollProgressToBottom(){ groupsContainer.scrollTop = groupsContainer.scrollHeight; }
function updateOverallProgress(loaded, total){ const pct = total? Math.round(loaded/total*100) : 0; overallBar.style.width = pct + '%'; overallPercent.textContent = pct + '%'; scrollProgressToBottom(); }
function createGroupProgress(groupId, label){ const row = document.createElement('div'); row.className='progress-row'; row.id = 'group-' + groupId; const lbl = document.createElement('div'); lbl.className='progress-label'; lbl.innerHTML = `<span>${escapeHtml(label)}</span><span class="group-percent" style="float:right">0%</span>`; const barBg = document.createElement('div'); barBg.className='progress-bar-bg'; const barFill = document.createElement('div'); barFill.className='progress-bar-fill'; barBg.appendChild(barFill); const fileList = document.createElement('div'); fileList.className='file-list'; row.appendChild(lbl); row.appendChild(barBg); row.appendChild(fileList); groupsContainer.appendChild(row); scrollProgressToBottom(); return { row, lbl, barFill, fileList }; }
function addFileStatus(fileListEl, fname){ const div = document.createElement('div'); div.className = 'file-status-row'; div.innerHTML = `<div style="display:flex;justify-content:space-between"><div>${escapeHtml(fname)}</div><div class="file-status">0%</div></div><div class="progress-bar-bg" style="margin-top:6px"><div class="progress-bar-fill" style="width:0%"></div></div>`; fileListEl.appendChild(div); scrollProgressToBottom(); return { container: div, progressFill: div.querySelector('.progress-bar-fill'), statusEl: div.querySelector('.file-status') }; }
function updateFileProgress(fileObj, loaded, total){ const pct = total ? Math.round(loaded/total*100) : 0; fileObj.progressFill.style.width = pct + '%'; fileObj.statusEl.textContent = pct + '%'; scrollProgressToBottom(); }
function updateGroupProgress(groupEl, loaded, total){ const pct = total? Math.round(loaded/total*100) : 0; groupEl.barFill.style.width = pct + '%'; const percentEl = groupEl.row.querySelector('.group-percent'); if(percentEl) percentEl.textContent = pct + '%'; scrollProgressToBottom(); }
function markGroupDone(groupEl, ok=true, msg='OK'){ groupEl.barFill.style.width = '100%'; const s = document.createElement('div'); s.textContent = ok ? (msg || 'OK') : ('ERR: ' + (msg||'')); s.style.marginTop='6px'; groupEl.fileList.appendChild(s); const percentEl = groupEl.row.querySelector('.group-percent'); if(percentEl) percentEl.textContent = '100%'; scrollProgressToBottom(); }

/* DELETE with progress: call permanent-delete per item and refresh manifest (force) after delete */
async function performBulkDelete(){
  if(selectedItems.size === 0) return alert('Chưa chọn mục để xóa');
  const auth = await ensureAuthForAction(); if(!auth.ok) return;
  const key = auth.key; // may be null if limited but then some worker endpoints may require key — depends on your worker 
  if(!confirm('Xác nhận xóa đã chọn?')) return;

  const items = Array.from(selectedItems).map(s=>{ const [size, barcode] = s.split('|'); return { size, barcode }; });
  showProgressPanel(); groupsContainer.innerHTML = '';
  let overallTotal = items.length, overallDone = 0;
  updateOverallProgress(0, overallTotal);

  for(const it of items){
    const gid = `${it.size}|${it.barcode}`;
    const groupEl = createGroupProgress(gid, `${it.size} — ${it.barcode}`);
    try{
      const res = await fetch(WORKER_BASE + '/permanent-delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-api-key': key },
        body: JSON.stringify({ size: it.size, barcode: it.barcode })
      });
      if(!res.ok){
        const txt = await res.text().catch(()=>res.statusText);
        markGroupDone(groupEl, false, txt || `${res.status}`);
      } else {
        const j = await res.json().catch(()=>null);
        markGroupDone(groupEl, true, j && j.deletedKeys ? `Deleted ${j.deletedKeys}` : 'Deleted');
      }
    } catch(err){
      console.error('delete error', err);
      markGroupDone(groupEl, false, err.message || 'Error');
    }
    overallDone++;
    updateOverallProgress(overallDone, overallTotal);
  }

  // rebuild manifest on worker (requires admin key)
  /*try{
  const r = await fetch(WORKER_BASE + '/refresh-manifest', { method: 'POST', headers: { 'x-api-key': key } });
  if(!r.ok) console.warn('refresh-manifest returned', r.status);
} catch(e){ console.warn('refresh-manifest error', e); }
*/
  // fetch fresh manifest (non-force)
  try { await fetchManifest(); } catch(e){ console.warn('fetchManifest after delete failed', e); }

  selectedItems.clear(); multiSelectMode=false; updateBodyMultiselectClass(); floatDelete.style.display='none'; renderAccording();
  alert('Xóa hoàn tất.');
}

/* floating delete */
floatDeleteBtn.onclick = performBulkDelete;

/* render functions (all/size/add) */
function renderAll(){
  contentEl.innerHTML = '';
  contentEl.appendChild(renderActionsBar());

  // mỗi size vẫn là một section; trong mỗi section, sort theo price nếu priceSortMode
  for(const s of manifest.sizes){
    const h = document.createElement('div'); h.className='section-title'; h.textContent = String(s.size); contentEl.appendChild(h);
    const grid = document.createElement('div'); grid.className='grid';

    // copy danh sách barcodes để không ảnh hưởng gốc
    let barcodes = Array.isArray(s.barcodes) ? s.barcodes.slice() : [];
    if(priceSortMode){
      barcodes.sort((a,b)=>{
        const pa = a && (a.price || a.price === 0) ? Number(String(a.price).replace(/[^\d]/g,'')) : Infinity;
        const pb = b && (b.price || b.price === 0) ? Number(String(b.price).replace(/[^\d]/g,'')) : Infinity;
        return (priceSortMode === 'asc') ? (pa - pb) : (pb - pa);
      });
    }

    for(const bc of barcodes) grid.appendChild(makeCard(s.size, bc, false));
    contentEl.appendChild(grid);
  }
}

function renderSize(sizeStr){
  contentEl.innerHTML = '';
  contentEl.appendChild(renderActionsBar());
  const s = manifest.sizes.find(x=>String(x.size)===String(sizeStr));
  if(!s){ contentEl.innerHTML='<div class="muted">Không có size này</div>'; return; }

  const grid = document.createElement('div'); grid.className='grid';
  let barcodes = Array.isArray(s.barcodes) ? s.barcodes.slice() : [];
  if(priceSortMode){
    barcodes.sort((a,b)=>{
      const pa = a && (a.price || a.price === 0) ? Number(String(a.price).replace(/[^\d]/g,'')) : Infinity;
      const pb = b && (b.price || b.price === 0) ? Number(String(b.price).replace(/[^\d]/g,'')) : Infinity;
      return (priceSortMode === 'asc') ? (pa - pb) : (pb - pa);
    });
  }
  for(const bc of barcodes) grid.appendChild(makeCard(s.size, bc, false));
  contentEl.appendChild(grid);
}

/* Sort & render "All" by price */
function applyPriceSortAndRender(mode) {
  // set mode và re-render theo tab hiện hành
  priceSortMode = mode;
  renderAccording();
}
/* RENDER ADD: full behaviour with requested tweaks */
function renderAdd(){
  contentEl.innerHTML = '';
  contentEl.appendChild(renderActionsBar());

  const container = document.createElement('div');
  container.style.padding = '12px'; container.style.borderRadius = '8px';

  const controls = document.createElement('div'); controls.style.display='flex'; controls.style.justifyContent='space-between'; controls.style.alignItems='center';
  const left = document.createElement('div'); left.className='controls-left';
  const addRowBtn = document.createElement('button'); addRowBtn.className='btn tab-like'; addRowBtn.textContent = 'Thêm dòng'; left.appendChild(addRowBtn);
  const uploadAllBtn = document.createElement('button'); uploadAllBtn.className='btn tab-like'; uploadAllBtn.textContent = 'Upload'; left.appendChild(uploadAllBtn);
  const globalAction = document.createElement('select'); const gOpt1 = document.createElement('option'); gOpt1.value='skip'; gOpt1.textContent='Skip if exists (Mặc định)'; const gOpt2 = document.createElement('option'); gOpt2.value='overwrite'; gOpt2.textContent='Overwrite if exists'; const gOpt3 = document.createElement('option'); gOpt3.value='upload'; gOpt3.textContent='Always upload'; globalAction.appendChild(gOpt1); globalAction.appendChild(gOpt2); globalAction.appendChild(gOpt3); globalAction.style.marginLeft='10px'; left.appendChild(globalAction);
  controls.appendChild(left);

  const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
  controls.appendChild(right);

  container.appendChild(controls);

  const tableWrap = document.createElement('div'); tableWrap.className='table-wrap'; tableWrap.style.marginTop='10px';
  const table = document.createElement('table'); table.className='table-add';
  const thead = document.createElement('thead'); thead.innerHTML = `<tr><th>Thumb</th><th>Barcode</th><th>Size</th><th>Price</th><th>Details</th><th>Action</th></tr>`; table.appendChild(thead);
  const tbody = document.createElement('tbody'); table.appendChild(tbody); tableWrap.appendChild(table); container.appendChild(tableWrap);

  const folderLabel = document.createElement('div'); folderLabel.className='muted'; folderLabel.style.marginTop='8px'; folderLabel.textContent='Optional: chọn folder "Shoes"';
  const folderInput = document.createElement('input'); folderInput.type='file'; folderInput.webkitdirectory=true; folderInput.directory=true; folderInput.multiple=true; folderInput.style.display='block'; folderInput.style.marginTop='8px';
  container.appendChild(folderLabel); container.appendChild(folderInput);

  function createSizeSelect(selected){
    const sel = document.createElement('select');
    for(const s of manifest.sizes){ const o = document.createElement('option'); o.value = s.size; o.textContent = s.size; if(String(s.size) === String(selected)) o.selected = true; sel.appendChild(o); }
    const oNew = document.createElement('option'); oNew.value='__new__'; oNew.textContent='Thêm size mới...'; sel.appendChild(oNew);
    return sel;
  }

  function addRow(prefill = {}){
    const tr = document.createElement('tr');
    const tdThumb = document.createElement('td'); const inputThumb = document.createElement('input'); inputThumb.type='file'; inputThumb.accept='image/*'; const thumbPreview = document.createElement('img'); thumbPreview.className='small-thumb'; thumbPreview.alt='thumb'; thumbPreview.style.display='none'; tdThumb.appendChild(inputThumb); tdThumb.appendChild(thumbPreview);
 inputThumb.onchange = (e) => { const f = e.target.files && e.target.files[0]; if(f){ thumbPreview.src = URL.createObjectURL(f); thumbPreview.style.display='block'; tr.__prefilledThumbFile = null; } else { thumbPreview.src = ''; thumbPreview.style.display='none'; } };

    const tdBarcode = document.createElement('td'); const inputBarcode = document.createElement('input'); inputBarcode.type='text'; inputBarcode.placeholder='146888'; if(prefill.barcode) inputBarcode.value = prefill.barcode; tdBarcode.appendChild(inputBarcode);

    const tdSize = document.createElement('td'); const sizeSelect = createSizeSelect(prefill.size|| (manifest.sizes[0] && manifest.sizes[0].size)); const newSizeInput = document.createElement('input'); newSizeInput.type='text'; newSizeInput.placeholder='Nhập size mới...'; newSizeInput.style.display='none'; newSizeInput.style.marginLeft='6px'; newSizeInput.style.minWidth='80px'; tdSize.appendChild(sizeSelect); tdSize.appendChild(newSizeInput);
    sizeSelect.onchange = ()=>{ if(sizeSelect.value === '__new__'){ newSizeInput.style.display='inline-block'; newSizeInput.value = ''; newSizeInput.focus(); } else { newSizeInput.style.display='none'; } };
    if(prefill.size && !manifestMap[String(prefill.size)]){ sizeSelect.value='__new__'; newSizeInput.style.display='inline-block'; newSizeInput.value = prefill.size; }

    // Price column (new)
    const tdPrice = document.createElement('td'); const priceInput = document.createElement('input'); priceInput.type='text'; priceInput.placeholder='1200000'; priceInput.style.width='110px';
    if(prefill.price) priceInput.value = String(prefill.price);
    tdPrice.appendChild(priceInput);

    const tdDetails = document.createElement('td'); const inputDetails = document.createElement('input'); inputDetails.accept = 'image/*'; inputDetails.multiple = true; inputDetails.type = 'file'; const detailsPreviewWrap = document.createElement('div'); detailsPreviewWrap.style.display='flex'; detailsPreviewWrap.style.gap='6px'; detailsPreviewWrap.style.marginTop='6px'; tdDetails.appendChild(inputDetails); tdDetails.appendChild(detailsPreviewWrap);
    inputDetails.onchange = (e) => { detailsPreviewWrap.innerHTML = ''; const files = Array.from(e.target.files || []); for(const f of files){ const img = document.createElement('img'); img.src = URL.createObjectURL(f); img.className='small-thumb'; detailsPreviewWrap.appendChild(img); } tr.__prefilledFiles = null; };
    if(prefill.detailFiles && prefill.detailFiles.length){ for(const f of prefill.detailFiles){ const img = document.createElement('img'); img.src = URL.createObjectURL(f); img.className='small-thumb'; detailsPreviewWrap.appendChild(img); } tr.__prefilledFiles = prefill.detailFiles.slice(); }

    const tdAction = document.createElement('td'); const removeBtn = document.createElement('button'); removeBtn.className='btn tab-like'; removeBtn.textContent='Xóa'; removeBtn.onclick = ()=> tr.remove(); const actionWrap = document.createElement('div'); actionWrap.className='row-actions'; actionWrap.appendChild(removeBtn); tdAction.appendChild(actionWrap);

    tr.appendChild(tdThumb); tr.appendChild(tdBarcode); tr.appendChild(tdSize); tr.appendChild(tdPrice); tr.appendChild(tdDetails); tr.appendChild(tdAction); tbody.appendChild(tr);

    if(prefill.thumbFile){ thumbPreview.src = URL.createObjectURL(prefill.thumbFile); thumbPreview.style.display='block'; tr.__prefilledThumbFile = prefill.thumbFile; }
    // store references
    tr.__fields = { inputThumb, inputBarcode, sizeSelect, newSizeInput, priceInput, inputDetails, detailsPreviewWrap };
    return { tr, inputThumb, thumbPreview, inputBarcode, sizeSelect, newSizeInput, inputDetails, detailsPreviewWrap, priceInput };
  }
  
  addRowBtn.onclick = ()=> addRow();

  uploadAllBtn.onclick = async ()=>{
    const auth = await ensureAuthForAction(); if(!auth.ok) return;
	const key = auth.key; 
    const rows = Array.from(tbody.querySelectorAll('tr'));
    if(rows.length===0) return alert('Chưa có dòng nào để upload');

    const rowInfos = rows.map(r=>{
      // updated indices because Price column added
      const inputThumb = r.querySelector('td:nth-child(1) input[type="file"]');
      const inputBarcode = r.querySelector('td:nth-child(2) input[type="text"]');
      const sizeSelect = r.querySelector('td:nth-child(3) select');
      const newSizeInput = r.querySelector('td:nth-child(3) input[type="text"]');
      const priceInput = r.querySelector('td:nth-child(4) input[type="text"]');
      const inputDetails = r.querySelector('td:nth-child(5) input[type="file"][multiple]');
      const barcode = (inputBarcode && inputBarcode.value || '').trim();
const sizeVal = sizeSelect ? sizeSelect.value : (newSizeInput ? newSizeInput.value : '');
      const priceVal = priceInput ? (priceInput.value || '').trim() : '';
      return { tr:r, inputThumb, inputBarcode, barcode, sizeSelect, sizeVal, newSizeInput, inputDetails, priceInput, priceVal };
    });

    for(const ri of rowInfos){
      if(!ri.barcode) return alert('Vui lòng nhập barcode cho tất cả dòng (hoặc xóa dòng trống)');
      let detailsFiles = Array.from((ri.inputDetails && ri.inputDetails.files) || []);
      if(detailsFiles.length === 0 && ri.tr.__prefilledFiles && ri.tr.__prefilledFiles.length) detailsFiles = ri.tr.__prefilledFiles.slice();
      if(detailsFiles.length === 0) return alert('Mỗi dòng cần ít nhất 1 ảnh detail');
    }

    const duplicates = rowInfos.filter(ri => {
      const effectiveSize = ri.sizeVal === '__new__' ? (ri.newSizeInput && ri.newSizeInput.value || '') : ri.sizeVal;
      return manifestHas(effectiveSize, ri.barcode);
    });
    if(duplicates.length > 0){
      const ga = globalAction ? globalAction.value : 'skip';
      const msg = `Found ${duplicates.length} existing barcode(s) in manifest.\nAction chosen: ${ga}.\n\nTiếp tục? (Hủy để chỉnh lại)`;
      if(!confirm(msg)) return;
    }

    const groups = [];
    for(const ri of rowInfos){
      let detailsFiles = Array.from((ri.inputDetails && ri.inputDetails.files) || []);
      if(detailsFiles.length === 0 && ri.tr.__prefilledFiles && ri.tr.__prefilledFiles.length) detailsFiles = ri.tr.__prefilledFiles.slice();
      let effectiveSize = ri.sizeVal;
      if(effectiveSize === '__new__'){ effectiveSize = (ri.newSizeInput && ri.newSizeInput.value || '').trim(); if(!effectiveSize) return alert('Bạn đã chọn Thêm size mới nhưng chưa nhập tên size.'); }
      if(manifestHas(effectiveSize, ri.barcode) && (globalAction && globalAction.value === 'skip')) continue;
      const prepared = [];
      let thumbFile = null;
      if(ri.inputThumb && ri.inputThumb.files && ri.inputThumb.files[0]) thumbFile = ri.inputThumb.files[0];
      else if(ri.tr.__prefilledThumbFile) thumbFile = ri.tr.__prefilledThumbFile;
      else if(detailsFiles.length>0) thumbFile = detailsFiles[0];
      if(thumbFile){ const thumb = new File([await thumbFile.arrayBuffer()], 'thumb.jpeg', { type: 'image/jpeg' }); prepared.push({ file: thumb, remoteName: 'thumb.jpeg' }); }
      for(const f of detailsFiles){ prepared.push({ file: f, remoteName: f.name }); }
      groups.push({ size: effectiveSize, barcode: ri.barcode, prepared, price: ri.priceVal || '' });
    }
if(groups.length === 0) return alert('Không có hàng để upload sau khi áp dụng skip rules');
    try{
      await uploadPreparedGroups(groups, key);
      let added = false; for(const g of groups){ if(!manifestMap[g.size]){ manifest.sizes.push({ size: String(g.size), barcodes: [] }); added = true; } }
      if(added){ buildManifestMap(); buildTabs(); }
      await fetchManifest();
      alert('Upload tất cả rows hoàn tất');
    } catch(e){ console.error(e); alert('Upload lỗi: ' + e.message); }
  };

  // folder input: validate top-level folder name is Shoes (if present)
  folderInput.onchange = async (e)=>{
    const files = Array.from(folderInput.files || []);
    if(!files.length) return; // don't show message
    // check if selected files include a top-level directory named 'Shoes' (case-insensitive)
    const sample = files[0].webkitRelativePath || files[0].name;
    const parts = sample.split('/').filter(Boolean);
    if(parts.length>0 && parts[0].toLowerCase() !== 'shoes'){
      alert('Vui lòng chọn thư mục "Shoes" (chứa các folder Size X). Xin chọn lại.');
      folderInput.value = '';
      return;
    }

    const groupsMap = {};
    for(const f of files){
      const rel = f.webkitRelativePath || f.name;
      const parts = rel.split('/').filter(Boolean);
      let idx = 0; if(parts[0] && parts[0].toLowerCase()==='shoes') idx=1;
      if(parts.length-idx < 3) continue;
      const size = parts[idx].trim();
      const barcode = parts[idx+1].trim();
      const fname = parts.slice(idx+2).join('/');
      if(!groupsMap[size]) groupsMap[size]={};
      if(!groupsMap[size][barcode]) groupsMap[size][barcode]=[];
      groupsMap[size][barcode].push({ file: f, relPath: fname });
    }

    for(const size of Object.keys(groupsMap)){
      for(const barcode of Object.keys(groupsMap[size])){
        const items = groupsMap[size][barcode];
        const detailFiles = items.filter(x=>!/^(price\.txt)$/i.test(x.relPath) && !/^thumb/i.test(x.relPath)).map(x=>x.file);
        const t = items.find(x=>/thumb\./i.test(x.relPath));
        const thumbFile = t ? t.file : (items[0] && items[0].file);
 // detect price.txt
        const p = items.find(x=>/^price\.txt$/i.test(x.relPath));
        let detectedPrice = '';
        if(p){
          try { const txt = await p.file.text(); const num = (txt||'').replace(/[^\d]/g,'').trim(); if(num) detectedPrice = num; } catch(e){ /* ignore */ }
        }
        const rowObj = addRow({ barcode, size, detailFiles, thumbFile, price: detectedPrice });
        rowObj.tr.__prefilledFiles = detailFiles.slice();
        if(thumbFile) rowObj.tr.__prefilledThumbFile = thumbFile;
        if(!manifestMap[size]){ rowObj.sizeSelect.value='__new__'; rowObj.newSizeInput.style.display='inline-block'; rowObj.newSizeInput.value = size; }
      }
    }
  };

  container.appendChild(document.createElement('br'));
  container.appendChild(tableWrap);
  contentEl.appendChild(container);
}

/* helper functions used by add tab upload */
function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[c])); }

function updateBodyMultiselectClass(){ if(multiSelectMode) document.body.classList.add('body-multiselect'); else document.body.classList.remove('body-multiselect'); }

/* UPLOAD utilities (presign + upload flow) */
function uploadFileWithProgress(url, file, onProgress){ return new Promise((resolve, reject) => { const xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); try { xhr.setRequestHeader('Content-Type', file.type); } catch(e){} xhr.upload.onprogress = (ev) => { if (ev.lengthComputable && typeof onProgress === 'function') onProgress(ev.loaded, ev.total); }; xhr.onload = () => { if (xhr.status >= 200 && xhr.status < 300) resolve({ ok:true, status: xhr.status, response: xhr.responseText }); else reject(new Error('Upload failed: ' + xhr.status + ' ' + xhr.statusText + ' - ' + xhr.responseText)); }; xhr.onerror = () => reject(new Error('Network error during upload')); xhr.send(file); }); }

async function uploadWithRetry(url, file, onProgress, attempts = 3) { for (let a = 1; a <= attempts; a++) { try { return await uploadFileWithProgress(url, file, onProgress); } catch (err) { if (a === attempts) throw err; await new Promise(r => setTimeout(r, 300 * a)); } } }

async function uploadPool(items, concurrency = 4) { let i = 0; const errors = []; const runners = Array.from({length: Math.min(concurrency, items.length)}, async () => { while (true) { const idx = i++; if (idx >= items.length) break; const it = items[idx]; try { await uploadWithRetry(it.url, it.file, it.onProgress); } catch (err) { console.warn('Upload failed for', it.url, err); errors.push({ idx, err }); } } }); await Promise.all(runners); if (errors.length) throw errors; }

async function convertImageFileToJpeg(file, maxWidth=1600, quality=0.80){ if(!file.type || !file.type.startsWith('image/')) return file; try{ const imgBitmap = await createImageBitmap(file); const scale = imgBitmap.width > maxWidth ? maxWidth / imgBitmap.width : 1; const w = Math.round(imgBitmap.width * scale); const h = Math.round(imgBitmap.height * scale); const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d'); ctx.drawImage(imgBitmap, 0, 0, w, h); const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality)); const newName = (file.name.replace(/\.[^/.]+$/, '') || 'image') + '.jpeg'; return new File([blob], newName, { type: 'image/jpeg' }); } catch(e){ console.warn('convertImageFileToJpeg failed', e); return file; } }

async function uploadPreparedGroups(preparedGroups, adminKey){
  let overallTotal = 0; for(const g of preparedGroups) for(const p of g.prepared) overallTotal += p.file.size;
  let overallLoaded = 0;
  showProgressPanel(); groupsContainer.innerHTML = ''; updateOverallProgress(0, overallTotal);

  for(const [gi, g] of preparedGroups.entries()){
    const gid = `${g.size}|${g.barcode}|${gi}`;
    if(!manifestMap[g.size]){ manifest.sizes.push({ size: String(g.size), barcodes: [] }); buildManifestMap(); buildTabs(); }
    const groupEl = createGroupProgress(gid, `${g.size} — ${g.barcode}`);
    const groupTotal = g.prepared.reduce((s,p)=>s + p.file.size, 0);
let groupLoaded = 0;
    const fileObjs = [];
    for(const p of g.prepared) fileObjs.push(addFileStatus(groupEl.fileList, p.remoteName));
    const filenames = g.prepared.map(p=>p.remoteName);
    const presignRes = await fetch(WORKER_BASE + '/presign-upload', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': adminKey }, body: JSON.stringify({ size: g.size, barcode: g.barcode, files: filenames, expiresIn: 3600 })});
    if(!presignRes.ok){ const t = await presignRes.text().catch(()=>presignRes.statusText); throw new Error('Presign failed: ' + t); }
    const presignJson = await presignRes.json(); const urls = presignJson.urls || {};
// --- START: replacement parallel upload block ---
const n = g.prepared.length;
const fileLoaded = new Array(n).fill(0); // track per-file uploaded bytes for delta
// prepare items for pool
const items = g.prepared.map((p, idx) => {
  const url = urls[p.remoteName];
  if (!url) throw new Error('Missing presigned URL for ' + p.remoteName);
  const fileObj = fileObjs[idx];
  return {
    idx,
    url,
    file: p.file,
    onProgress: (loaded, total) => {
      // delta since last progress event for this file
      const delta = Math.max(0, loaded - fileLoaded[idx]);
      fileLoaded[idx] = loaded;
      // update UI using delta
      updateFileProgress(fileObj, loaded, total);
      groupLoaded += delta;
      overallLoaded += delta;
      updateGroupProgress(groupEl, Math.min(groupLoaded, groupTotal), groupTotal);
      updateOverallProgress(overallLoaded, overallTotal);
    }
  };
});

try {
  // run concurrent uploads (tune concurrency number: 4 is a good start)
  await uploadPool(items, 4);

  // mark each file as fully uploaded and update loaded counters to full size
  for (let idx = 0; idx < n; idx++) {
 const p = g.prepared[idx];
    const fileObj = fileObjs[idx];
    // ensure final progress shows full size
    updateFileProgress(fileObj, p.file.size, p.file.size);
    // if fileLoaded[idx] < size, add remaining delta
    const remaining = Math.max(0, p.file.size - fileLoaded[idx]);
    if (remaining > 0) {
      groupLoaded += remaining;
      overallLoaded += remaining;
      updateGroupProgress(groupEl, Math.min(groupLoaded, groupTotal), groupTotal);
      updateOverallProgress(overallLoaded, overallTotal);
    }
    fileObj.statusEl.textContent = 'OK';
  }
} catch (errs) {
  // mark failed ones (errs is array of {idx, err}) and rethrow to abort group
  if (Array.isArray(errs)) {
    for (const e of errs) {
      const fo = fileObjs[e.idx];
      if (fo) fo.statusEl.textContent = 'ERR';
    }
  }
  console.error('Upload group error', errs);
  throw errs;
}
// --- END replacement block ---

    // complete upload: include price in body; include adminKey header as well
    const complete = await fetch(WORKER_BASE + '/complete-upload', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': adminKey }, body: JSON.stringify({ size: g.size, barcode: g.barcode, price: g.price || '' })});
    if(!complete.ok){ const t = await complete.text().catch(()=>complete.statusText); throw new Error('Complete-upload failed: ' + t); }
    updateOverallProgress(overallLoaded, overallTotal);
  }

  updateOverallProgress(overallLoaded, overallTotal);
}

/* render helpers & search */
function renderAccording(){ updateBodyMultiselectClass(); if(activeTab==='all') renderAll(); else if(activeTab.startsWith('size:')) renderSize(activeTab.split(':')[1]); else if(activeTab==='add') renderAdd(); }

searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { const q = searchInput.value || ''; doSearch(q); } });
function doSearch(query) { const q = String(query || '').trim(); if (!q) { renderAccording(); return; } const qLower = q.toLowerCase(); const results = []; for (const s of (manifest.sizes || [])) { const matched = (s.barcodes || []).filter(b => { const code = String(b.code || '').toLowerCase(); return code.includes(qLower); }); if (matched.length) results.push({ size: s.size, barcodes: matched }); } contentEl.innerHTML = ''; contentEl.appendChild(renderActionsBar()); if (!results.length) { const no = document.createElement('div'); no.className = 'muted'; no.textContent = `Không tìm thấy mã nào chứa "${q}".`; contentEl.appendChild(no); return; } for (const group of results) { const h = document.createElement('div'); h.className = 'section-title'; h.textContent = String(group.size); contentEl.appendChild(h); const grid = document.createElement('div'); grid.className = 'grid'; let barcodes = group.barcodes.slice(); if (priceSortMode) { barcodes.sort((a, b) => { const pa = a && (a.price || a.price === 0) ? Number(String(a.price).replace(/[^\d]/g,'')) : Infinity; const pb = b && (b.price || b.price === 0) ? Number(String(b.price).replace(/[^\d]/g,'')) : Infinity; return (priceSortMode === 'asc') ? (pa - pb) : (pb - pa); }); } for (const bc of barcodes) { grid.appendChild(makeCard(group.size, bc, false)); } contentEl.appendChild(grid); } window.scrollTo({ top: 0, behavior: 'smooth' }); }

/* refresh & clear key */
refreshBtn.onclick = async ()=> { try{ const key = await promptAndValidateAdminKey(); if(!key) return; const r = await fetch(WORKER_BASE + '/refresh-manifest', { method:'POST', headers:{ 'x-api-key': key }}); if(!r.ok){ const t = await r.text().catch(()=>r.statusText); throw new Error('Refresh failed: ' + t); } await fetchManifest(); alert('Manifest rebuilt'); } catch(err){ console.error(err); alert('Refresh error: ' + err.message); } };

/* share single card */
// shareMultipleImages - tải nhiều ảnh song song, xử lý retry, fallback, rồi gọi navigator.share
async function shareMultipleImages(size, barcodeObj) {
  try {
    //console.log('shareMultipleImages: chuẩn bị lấy ảnh...');
    const encSize = encodeURIComponent(String(size).trim());
    const encCode = encodeURIComponent(String(barcodeObj.code || '').trim());
    const names = Array.isArray(barcodeObj.images) ? barcodeObj.images.slice() : [];
    if (names.length === 0) {
      console.warn('Không có ảnh để chia sẻ');
      return alert('Không có ảnh để chia sẻ');
    }

    const concurrency = 10;
    const files = [];
    let idx = 0;

    // fetch 1 file via worker, return File or null
    async function fetchOne(name) {
      const fn = String(name || '').trim();
      const url = `${R2_PUBLIC_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(fn)}`;
      try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) {
          console.warn('fetch failed', res.status, url);
          return null;
        }
        const blob = await res.blob();
        return new File([blob], fn || (decodeURIComponent(url.split('/').pop())), { type: blob.type || 'application/octet-stream' });
      } catch (e) {
        console.warn('fetch error', url, e);
        return null;
      }
    }

    // simple concurrency pool
    const runners = Array.from({ length: Math.min(concurrency, names.length) }, async () => {
      while (true) {
        const i = idx++;
        if (i >= names.length) break;
        const f = await fetchOne(names[i]);
        if (f) files.push(f);
      }
    });
    await Promise.all(runners);

    // (modal removed) thay bằng log
    console.log('shareMultipleImages: thu thập xong', files.length, 'file(s)');

    if (files.length === 0) {
      // fallback: share worker URLs as text
      const urls = names.map(n => `${R2_PUBLIC_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(String(n).trim())}`);
      try {
        await navigator.share({ title: `Ảnh ${barcodeObj.code || ''}`, text: urls.join('\n') });
        return;
      } catch (e) {
        console.warn('fallback share URLs failed', e);
        return alert('Không thu thập được file nào để chia sẻ');
      }
    }

    // check canShare if available
    try {
      if (navigator.canShare && !navigator.canShare({ files })) {
        // cannot share files -> fallback to first URL
        const first = `${R2_PUBLIC_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(String(names[0]).trim())}`;
        try {
          await navigator.share({ title: `Ảnh ${barcodeObj.code || ''}`, text: first });
        } catch (e) {
          console.warn('fallback to first URL failed', e);
          alert('Trình duyệt không hỗ trợ chia sẻ file trực tiếp');
        }
        return;
      }
    } catch (e) {
      console.warn('navigator.canShare check error (ignored)', e);
    }

    // attempt share files
    try {
      await navigator.share({ files, title: `Ảnh ${barcodeObj.code || ''}` });
    } catch (e) {
      console.warn('share files failed, fallback to URLs', e);
      const urls = names.map(n => `${R2_PUBLIC_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(String(n).trim())}`);
      try { await navigator.share({ title: `Ảnh ${barcodeObj.code || ''}`, text: urls.join('\n') }); }
      catch (e2) {
        console.warn('fallback share URLs also failed', e2);
      }
    }
  } catch (err) {
    console.error('shareMultipleImages error', err);
    alert('Lỗi khi chia sẻ: ' + (err && err.message ? err.message : String(err)));
  }
}
// ------------------ Import Giá Vốn (client) ------------------
const importVonBtn = document.getElementById('import-von-btn');
const importVonInput = document.getElementById('import-von-input');

importVonBtn.addEventListener('click', ()=> importVonInput.click());

importVonInput.addEventListener('change', async (e) => {
  const f = importVonInput.files && importVonInput.files[0];
  if(!f) return;
  if(!confirm('Import giá vốn: file sẽ được đọc cột G = code, cột C = giá vốn. Tiếp tục?')) { importVonInput.value=''; return; }
  try {
    const ab = await f.arrayBuffer();
    const wb = XLSX.read(ab, { type: 'array' });
    const ws = wb.Sheets[wb.SheetNames[0]];
    if(!ws || !ws['!ref']) throw new Error('Không đọc được sheet/trống');
    const range = XLSX.utils.decode_range(ws['!ref']);
    const rows = [];
    // assume headers at row 0; start at row 1
    for (let r = range.s.r + 1; r <= range.e.r; r++) {
      const cellG = ws[XLSX.utils.encode_cell({c:6, r})]; // G
      const cellC = ws[XLSX.utils.encode_cell({c:2, r})]; // C
      const code = cellG && cellG.v ? String(cellC.v).trim() : '';
      const von = cellC && (cellC.v !== undefined && cellH.v !== null) ? String(cellH.v).replace(/[^\d]/g,'').trim() : '';
      if (code) rows.push({ code, von });
    }
    if (rows.length === 0) return alert('Không tìm thấy dòng hợp lệ trong file.');
    // ask admin key to import (import requires admin)
    const adminKey = await promptAndValidateAdminKey();
    if (!adminKey) return alert('Cần admin key để import.');
    // send in chunks if very large (optional). We'll send all at once.
    const res = await fetch(WORKER_BASE + '/import-von', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': adminKey },
      body: JSON.stringify({ rows })
    });
    const j = await res.json().catch(()=>null);
    if (!res.ok) {
      const txt = j && j.error ? j.error : await res.text().catch(()=>res.statusText);
      throw new Error(txt || ('Status ' + res.status));
    }
    alert('Import hoàn tất: ' + (j && j.summary ? `added ${j.summary.added}, updated ${j.summary.updated}, skipped ${j.summary.skipped}` : 'OK'));
    importVonInput.value = '';
    // refresh local von display if modal open: optional fetchManifest or just leave as-is
    await fetchManifest(); // optional to refresh manifest if you want von to appear somewhere
  } catch (err) {
    console.error('import-von error', err);
    alert('Import lỗi: ' + (err && err.message ? err.message : err));
    importVonInput.value = '';
  }
});

/* init */
async function init(){ priceSortMode = 'asc'; await fetchManifest(); updateBodyMultiselectClass(); floatDelete.style.display = 'none'; handleScroll(); renderAccording(); initExportThumbs()}
init();
updateRoleVisibility();
document.addEventListener('DOMContentLoaded', ()=>{ updateRoleVisibility(); });

// ---------- Thumbnail export: UI + generator ----------
function initExportThumbs(){
  const btn = document.getElementById('btn-export-thumbs');
  if(!btn) return;
  const role = (typeof getRole === 'function') ? getRole() : 'anon';
  btn.style.display = (role === 'anon') ? 'none' : 'inline-block';
  btn.onclick = openExportThumbsUI;
}

/* small helpers */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function loadImageElement(url, timeout = 12000) {
  return new Promise((resolve) => {
    try {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      let done = false;
      const t = setTimeout(()=> {
        if (done) return;
        done = true;
        try{ img.src = ''; }catch(e){}
        resolve(null);
      }, timeout);
      img.onload = () => { if (done) return; done = true; clearTimeout(t); resolve(img); };
      img.onerror = () => { if (done) return; done = true; clearTimeout(t); resolve(null); };
      img.src = url;
    } catch(e){ resolve(null); }
  });
}
function roundRectPath(ctx, x, y, w, h, r) {
  const radius = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + w - radius, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
  ctx.lineTo(x + w, y + h - radius);
  ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
  ctx.lineTo(x + radius, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}
async function createGridFromUrls(urls, opts = {}) {
  const cols = Number(opts.cols || 6);
  const rows = Number(opts.rows || 6);
  const gap = Number(opts.gap || 8);
  const thumbSize = Number(opts.thumbSize || 160);
  const cornerRadius = Number(opts.cornerRadius || 12);
  const perGrid = cols * rows;

  const canvasW = cols * thumbSize + (cols + 1) * gap;
  const canvasH = rows * thumbSize + (rows + 1) * gap;

  const dpr = (typeof window !== 'undefined' && window.devicePixelRatio) ? Math.max(1, Math.floor(window.devicePixelRatio)) : 1;

  let canvas, ctx;
  if (typeof OffscreenCanvas !== 'undefined') {
    canvas = new OffscreenCanvas(Math.round(canvasW * dpr), Math.round(canvasH * dpr));
    ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
  } else {
    canvas = document.createElement('canvas');
    canvas.width = Math.round(canvasW * dpr);
    canvas.height = Math.round(canvasH * dpr);
    canvas.style.width = canvasW + 'px';
    canvas.style.height = canvasH + 'px';
    ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
  }

  ctx.fillStyle = opts.bg || '#ffffff';
  ctx.fillRect(0,0,canvasW,canvasH);

  for (let i = 0; i < perGrid; i++) {
    const url = urls[i];
    const r = Math.floor(i / cols);
    const c = i % cols;
    const x = gap + c * (thumbSize + gap);
    const y = gap + r * (thumbSize + gap);

    if (!url) continue;

    const img = await loadImageElement(url, 14000);
    if (!img) continue;

    try {
      ctx.save();
      roundRectPath(ctx, x, y, thumbSize, thumbSize, cornerRadius);
      ctx.clip();

      const iw = img.naturalWidth || img.width || thumbSize;
      const ih = img.naturalHeight || img.height || thumbSize;
      const scale = Math.max(thumbSize / iw, thumbSize / ih);
      const dw = Math.ceil(iw * scale);
      const dh = Math.ceil(ih * scale);
      const dx = x + Math.floor((thumbSize - dw) / 2);
      const dy = y + Math.floor((thumbSize - dh) / 2);
      ctx.drawImage(img, dx, dy, dw, dh);

      ctx.restore();
    } catch (e) {
      try { ctx.restore(); } catch(e){}
    } finally {
      try { img.src = ''; } catch(e){}
    }

    if (i % 6 === 0) await sleep(20);
  }

  if (canvas.convertToBlob) {
    return await canvas.convertToBlob({ type: 'image/png' });
  } else {
    return await new Promise((resolve) => canvas.toBlob((b)=>resolve(b), 'image/png', 0.92));
  }
}

function chunkArray(arr, size){
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

function sanitizeName(s){
  return String(s||'').replace(/^Size\s*/i,'').replace(/\s+/g,'_').replace(/[^\w\-\.]/g,'');
}

function buildThumbUrl(size, code, thumbName='thumb.jpeg'){
  const encSize = encodeURIComponent(String(size).trim());
  const encCode = encodeURIComponent(String(code).trim());
  return `${WORKER_BASE1}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(thumbName)}`;
}

/* open small UI for choosing which sizes / all then export */
function openExportThumbsUI(){
  // hide header Price/Vốn/Thay giá/Close while export UI is open; save previous styles to restore later
  const modalHeaderLeftEl = document.getElementById('modalHeaderLeft');
  const modalHeaderRightEl = document.getElementById('modalHeaderRight');
  const modalCloseBtn = document.getElementById('modalClose');
  const changePriceBtnEl = document.getElementById('changePriceBtn');
  const prevHeaderLeftDisplay = modalHeaderLeftEl ? modalHeaderLeftEl.style.display : null;
  const prevHeaderRightDisplay = modalHeaderRightEl ? modalHeaderRightEl.style.display : null;
  const prevModalCloseDisplay = modalCloseBtn ? modalCloseBtn.style.display : null;
  const prevChangePriceDisplay = changePriceBtnEl ? changePriceBtnEl.style.display : null;

  if (modalHeaderLeftEl) modalHeaderLeftEl.style.display = 'none';
  if (modalHeaderRightEl) {
    // keep header right but hide the header-level close button specifically
    if (modalCloseBtn) modalCloseBtn.style.display = 'none';
    // also hide changePrice button in header area
    if (changePriceBtnEl) changePriceBtnEl.style.display = 'none';
  }

  // panel UI
  const panel = document.createElement('div');
  panel.style.minWidth='360px';
  panel.style.maxHeight='70vh';
  panel.style.overflow='auto';
  panel.style.padding='12px';
  panel.style.display='flex';
  panel.style.flexDirection='column';
  panel.style.gap='8px';

  const title = document.createElement('div');
  title.style.fontWeight='700'; title.textContent = 'Xuất thumbnails (grid 6×6)';
  panel.appendChild(title);

  // controls row: replace the "All checkbox" with Tick all / Untick all buttons
  const controls = document.createElement('div');
  controls.style.display='flex'; controls.style.gap='8px'; controls.style.alignItems='center';
  const tickAllBtn = document.createElement('button'); tickAllBtn.className='btn'; tickAllBtn.textContent='Tick all';
  const untickAllBtn = document.createElement('button'); untickAllBtn.className='btn'; untickAllBtn.textContent='Untick all';
  controls.appendChild(tickAllBtn);
  controls.appendChild(untickAllBtn);
  panel.appendChild(controls);

  const listWrap = document.createElement('div');
  listWrap.style.display='grid';
  listWrap.style.gridTemplateColumns='repeat(2,1fr)';
  listWrap.style.gap='6px';

  const sizes = (manifest && Array.isArray(manifest.sizes)) ? manifest.sizes.map(s=>String(s.size)) : [];
  sizes.forEach(sz=>{
    const label = document.createElement('label');
    label.style.display='flex'; label.style.gap='8px'; label.style.alignItems='center';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.className='export-size-checkbox'; cb.dataset.size = sz;
    label.appendChild(cb);
    const txt = document.createElement('span'); txt.textContent = String(sz);
    label.appendChild(txt);
    listWrap.appendChild(label);
  });
  panel.appendChild(listWrap);

  // action buttons: keep Đóng here (near Xuất) and Xuất
  const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px';
  const btnCancel = document.createElement('button'); btnCancel.className='btn'; btnCancel.textContent='Đóng';
  const btnExport = document.createElement('button'); btnExport.className='btn primary'; btnExport.textContent='Xuất';
  actions.appendChild(btnCancel); actions.appendChild(btnExport);
  panel.appendChild(actions);

  // wiring tick all / untick all
  tickAllBtn.onclick = ()=>{ listWrap.querySelectorAll('input.export-size-checkbox').forEach(i=>i.checked=true); };
  untickAllBtn.onclick = ()=>{ listWrap.querySelectorAll('input.export-size-checkbox').forEach(i=>i.checked=false); };

  // cancel -> close modal and restore header state
  btnCancel.onclick = ()=> {
    // restore header visuals
    try {
      if (modalHeaderLeftEl) modalHeaderLeftEl.style.display = (prevHeaderLeftDisplay === null ? '' : prevHeaderLeftDisplay);
      if (modalHeaderRightEl) modalHeaderRightEl.style.display = (prevHeaderRightDisplay === null ? '' : prevHeaderRightDisplay);
      if (modalCloseBtn) modalCloseBtn.style.display = (prevModalCloseDisplay === null ? '' : prevModalCloseDisplay);
      if (changePriceBtnEl) changePriceBtnEl.style.display = (prevChangePriceDisplay === null ? '' : prevChangePriceDisplay);
    } catch(e){ console.warn('restore header failed', e); }
    document.getElementById('modalClose').click();
  };

  // show modal (title + panel in body)
  showModal('Xuất thumbnails', panel);

  btnExport.onclick = async ()=>{
    const checked = Array.from(listWrap.querySelectorAll('input.export-size-checkbox:checked')).map(i=>String(i.dataset.size));
    const exportAll = checked.length === 0; // none checked => treat as All
    let sizesToExport = exportAll ? sizes.slice() : checked.slice();

    if (!sizesToExport || sizesToExport.length === 0) { alert('Không có kích cỡ để xuất'); return; }

    const perGrid = 36;
    const thumbPixel = 220;

    const items = [];
    for (const sz of sizesToExport) {
      const sObj = manifest.sizes.find(x => String(x.size) === String(sz));
      if (!sObj || !Array.isArray(sObj.barcodes)) continue;
      for (const b of sObj.barcodes) {
        const tn = (Array.isArray(b.images) && b.images.find(n=>/thumb/i.test(n))) || (Array.isArray(b.images) && b.images[0]) || 'thumb.jpeg';
        items.push({ size: sz, code: String(b.code), thumbName: tn });
      }
    }

    if (items.length === 0) { alert('Không có ảnh để xuất'); return; }

    const allUrls = items.map(it => buildThumbUrl(it.size, it.code, it.thumbName));
    const pages = chunkArray(allUrls, perGrid);

    showProgressPanel();
    groupsContainer.innerHTML = '';
    const groupEl = createGroupProgress('export-thumbs', `Xuất thumbnails — Tổng trang: ${pages.length}`);
    updateOverallProgress(0, pages.length);

    const useZip = (typeof JSZip !== 'undefined');
    const zip = useZip ? new JSZip() : null;

    let pageIdx = 0;
    for (const pageUrls of pages) {
      pageIdx++;
      try {
        // use requested opts: gap:4, cornerRadius:7
        const blob = await createGridFromUrls(pageUrls, { cols:6, rows:6, thumbSize: thumbPixel, gap:4, bg:'#ffffff', cornerRadius:7 });
        const fname = pages.length === 1 ? `Thumbnail.png` : `Thumbnail_P${pageIdx}.png`;

        if (useZip && zip) {
          zip.file(fname, blob);
        } else {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fname;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          await sleep(120);
        }

        markGroupDone(groupEl, true, `Page ${pageIdx}`);
      } catch (err) {
        console.error('Export page failed', pageIdx, err);
        markGroupDone(groupEl, false, `Page ${pageIdx} error`);
      }
      updateOverallProgress(pageIdx, pages.length);
      await sleep(80);
    }

    if (useZip && zip) {
      try {
        const content = await zip.generateAsync({ type: 'blob' }, (meta) => {
          const pct = Math.round(meta.percent || 0);
          overallBar.style.width = pct + '%';
          overallPercent.textContent = pct + '%';
        });
        const u = URL.createObjectURL(content);
        const a = document.createElement('a'); a.href = u;
        a.download = `Thumbnail_${PREFIX}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.zip`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(u);
      } catch(e){
        console.error('Zip create failed', e);
        alert('Tạo file zip thất bại: ' + (e && e.message ? e.message : e));
      }
    }

    markGroupDone(groupEl, true, 'Hoàn tất');
    updateOverallProgress(pages.length, pages.length);
    await sleep(300);
    hideProgressPanel();

    // restore header visuals after finish
    try {
      if (modalHeaderLeftEl) modalHeaderLeftEl.style.display = (prevHeaderLeftDisplay === null ? '' : prevHeaderLeftDisplay);
      if (modalHeaderRightEl) modalHeaderRightEl.style.display = (prevHeaderRightDisplay === null ? '' : prevHeaderRightDisplay);
      if (modalCloseBtn) modalCloseBtn.style.display = (prevModalCloseDisplay === null ? '' : prevModalCloseDisplay);
      if (changePriceBtnEl) changePriceBtnEl.style.display = (prevChangePriceDisplay === null ? '' : prevChangePriceDisplay);
    } catch(e){ console.warn('restore header failed', e); }

    document.getElementById('modalClose').click();
  };
}

// initialize after manifest loaded & UI wiring
(function(){ // call this at end of init or after fetchManifest()
  // show export thumbs button only if logged in
  try{ initExportThumbs(); }catch(e){console.warn('initExportThumbs fail', e);}
})();
 // ---------- end Thumbnail export ----------


</script>
</body>
</html>
